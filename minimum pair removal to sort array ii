class Solution {
public:
    int minimumPairRemoval(vector<int>& nums) {
        int n = (int)nums.size();
        vector<long long> arr(nums.begin(), nums.end());
        
        vector<int> next(n, -1);
        vector<int> prev(n, -1);

        int inv = 0;
        int ops = 0;

        priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > pq;

        for (int i = 0; i < n - 1; i++)
        {
            next[i] = i + 1;
            prev[i + 1] = i;

            if (arr[i] > arr[i + 1]) {
                ++inv;
            }

            pq.emplace(arr[i] + arr[i + 1], i);
        }

        while (inv)
        {
            auto [sum, i] = pq.top();
            pq.pop();

            int j = next[i];

            if (j == -1 || prev[j] != i || arr[i] + arr[j] != sum) {
                continue;
            }
            
            ++ops;
            
            if (prev[i] != -1 && arr[prev[i]] > arr[i]) {
                --inv;
            }

            if (arr[i] > arr[j]) {
                --inv;
            }

            if (next[j] != -1 && arr[j] > arr[next[j]]) {
                --inv;
            }

            if (prev[i] != -1 && arr[prev[i]] > sum) {
                ++inv;
            }

            if (next[j] != -1 && sum > arr[next[j]]) {
                ++inv;
            }

            arr[i] = sum;

            next[i] = next[j];
            
            if (next[j] != -1) {
                prev[next[j]] = i;
            }

            if (prev[i] != -1) {
                pq.emplace(arr[prev[i]] + sum, prev[i]);
            }

            if (next[i] != -1) {
                pq.emplace(sum + arr[next[i]], i);
            }

            next[j] = -1;
            prev[j] = -1;
        }

        return ops;
    }
};
