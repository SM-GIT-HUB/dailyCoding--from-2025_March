class Solution {
public:
    int disc[1001];
    int parent[1001];

    class DSU {
    public:
        vector<int> size;
        vector<int> parent;

        DSU(int n)
        {
            parent.resize(n);
            for (int i = 0; i < n; i++) parent[i] = i;
        }

        int findUltParent(int node)
        {
            if (parent[node] == node) return node;
            return parent[node] = findUltParent(parent[node]);
        }

        void unionBySize(int u, int v, unordered_set<int>& sett)
        {
            int uPar = findUltParent(u);
            int vPar = findUltParent(v);

            if (uPar == vPar) {
                sett.insert(u);
            }
            else
                parent[vPar] = parent[uPar];
        }
    };

    void bfs(int node, int &cycle, vector<vector<int> >& adj)
    {
        queue<int> q;
        for (int i = 0; i < adj.size(); i++) disc[i] = 0;

        q.push(node);
        disc[node] = 1;
        parent[node] = -1;

        while (!q.empty())
        {
            int u = q.front();
            q.pop();

            for (int v : adj[u])
            {
                if (!disc[v])
                {
                    disc[v] = disc[u] + 1;
                    parent[v] = u;
                    q.push(v);
                }
                else if (parent[u] != v)
                {
                    int cl = disc[u] + disc[v] - 1;
                    
                    if (cl <= cycle) {
                        cycle = cl;
                    }
                    else
                        break;
                }
            }
        }
    }

    int findShortestCycle(int n, vector<vector<int> >& edges) {
        DSU ds(n);
        unordered_set<int> sett;
        vector<vector<int> > adj(n);

        for (auto &e : edges)
        {
            adj[e[0]].push_back(e[1]);
            adj[e[1]].push_back(e[0]);
            ds.unionBySize(e[0], e[1], sett);
        }

        int cycle = 1e9;
        
        for (int node: sett)
        {
            bfs(node, cycle, adj);
        }

        return (cycle < 1e9)? cycle : -1;
    }
};
