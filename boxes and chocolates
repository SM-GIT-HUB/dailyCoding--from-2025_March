#include <bits/stdc++.h>

int mod = 1e9 + 7;

class SegTree {
public:
    int size;
    vector<array<long long, 3> > tree;

    void buildTree(int idx, int start, int end, vector<int>& arr)
    {
        if (start == end)
        {
            tree[idx] = {1, 0, 0};
            tree[idx][arr[start] % 3]++;
            return;
        }

        int left = (idx << 1) + 1;
        int right = left + 1;
        int mid = (start + end) >> 1;

        buildTree(left, start, mid, arr);
        buildTree(right, mid + 1, end, arr);

        tree[idx] = {0, 0, 0};

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                tree[idx][(i + j) % 3] += (tree[left][i] * tree[right][j]) % mod;
            }
        }
    }

    void pointUpdate(int idx, int start, int end, int point, int val)
    {
        if (start == end)
        {
            tree[idx] = {1, 0, 0};
            tree[idx][val % 3]++;
            return;
        }

        int left = (idx << 1) + 1;
        int right = left + 1;
        int mid = (start + end) >> 1;

        if (point <= mid) {
            pointUpdate(left, start, mid, point, val);
        }
        else
            pointUpdate(right, mid + 1, end, point, val);

        tree[idx] = {0, 0, 0};

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                tree[idx][(i + j) % 3] += (tree[left][i] * tree[right][j]) % mod;
            }
        }
    }

    array<long long, 3> rangeQuery(int idx, int start, int end, int qStart, int qEnd)
    {
        if (end < qStart || qEnd < start) return {1, 0, 0};
        if (qStart <= start && end <= qEnd) return tree[idx];

        int left = (idx << 1) + 1;
        int right = left + 1;
        int mid = (start + end) >> 1;

        array<long long, 3> leftArr = rangeQuery(left, start, mid, qStart, qEnd);
        array<long long, 3> rightArr = rangeQuery(right, mid + 1, end, qStart, qEnd);

        array<long long, 3> curr = {0, 0, 0};

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                curr[(i + j) % 3] += (leftArr[i] * rightArr[j]) % mod;
            }
        }

        return curr;
    }

    SegTree(vector<int>& arr)
    {
        size = arr.size();
        tree.resize(4 * size);
        buildTree(0, 0, size - 1, arr);
    }

    void updatePoint(int point, int val)
    {
        pointUpdate(0, 0, size - 1, point, val);
    }

    int queryRange(int qStart, int qEnd)
    {
        return (rangeQuery(0, 0, size - 1, qStart, qEnd)[0] - 1) % mod;
    }
};

int itr(vector<int>& arr)
{
    long long sum = 0;
    long long count = 0;

    unordered_map<int, long long> mapp;
    mapp[0] = 1;

    for (int x : arr)
    {
        sum += x;
        int rem = sum % 3;

        count += mapp[rem];
        mapp[rem]++;
    }

    return (count % mod);
}

vector<vector<int> > maxNumberOfWays(vector<int> &arr, int n, int q, vector<vector<int>> &queries){
    // Write your code here.
    vector<vector<int> > ans(3);

    SegTree st(arr);

    ans[0] = {st.queryRange(0, n - 1)};
    ans[1] = {itr(arr)};

    for (auto &q : queries)
    {
        if (q[0] == 0) {
            st.updatePoint(q[1] - 1, q[2]);
        }
        else
        {
            int curr = st.queryRange(q[1] - 1, q[2] - 1);
            ans[2].push_back(curr);
        }
    }

    return ans;
}
