
int timer = 0;

void dfs(int node, int parent, vector<int>& time, vector<int>& low, vector<int>& visited, vector<vector<int> >& adj, vector<vector<int> >& ans)
{
	visited[node] = 1;
	time[node] = timer;
	low[node] = timer++;

	for (int adjNode: adj[node])
	{
		if (!visited[adjNode])
		{
			dfs(adjNode, node, time, low, visited, adj, ans);
			low[node] = min(low[node], low[adjNode]);

			if (low[adjNode] > time[node]) ans.push_back({node, adjNode});
		}
		else if (adjNode != parent) {
			low[node] = min(low[node], time[adjNode]);
		}
	}
}

vector< vector<int> > criticalConnections(int n, vector<vector<int>> & connections) 
{
	// Write your code here.
	timer = 0;

	vector<int> low(n);
	vector<int> time(n);

	vector<int> visited(n);
	vector<vector<int> > ans;
	vector<vector<int> > adj(n);
	
	for (auto &c : connections)
	{
		int u = c[0], v = c[1];
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	for (int node = 0; node < n; node++)
	{
		if (!visited[node]) dfs(node, -1, time, low, visited, adj, ans);
	}

	return ans;
}
